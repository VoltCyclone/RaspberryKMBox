/**
 * KMBox FPGA Bridge - Main Firmware
 *
 * Runs on the RP2350 side of the pico2-ice board.
 * The iCE40 FPGA handles all KMBox UART communication while
 * the RP2350 handles:
 *   - USB CDC interface for receiving commands/frames from PC
 *   - Color tracking (when frames are received)
 *   - TFT display rendering (via SPI)
 *   - FPGA command submission (via SPI register writes)
 *   - FPGA status polling (via SPI register reads)
 *
 * Architecture:
 *   PC ←(USB CDC)→ RP2350 ←(SPI regs)→ iCE40 FPGA ←(UART 3M)→ KMBox
 *
 * The FPGA bitstream is embedded as a C array and loaded via CRAM
 * on every boot (no flash programming required for the FPGA).
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pico/stdlib.h"
#include "pico/binary_info.h"
#include "hardware/spi.h"
#include "hardware/clocks.h"
#include "hardware/adc.h"

// pico-ice-sdk (ice_usb.h pulls in tusb.h)
#include "boards.h"
#include "ice_usb.h"
#include "ice_fpga.h"
#include "ice_cram.h"
#include "ice_led.h"

// Local modules
#include "fpga_spi.h"
#include "bridge_fpga_regs.h"
#include "config.h"
#include "tracker.h"

// FPGA bitstream (generated by synthesis toolchain → bin2header.py)
#include "bitstream.h"

// ============================================================================
// Configuration
// ============================================================================

#define CDC_RX_BUFFER_SIZE  4096
#define STATUS_POLL_MS      100    // Poll FPGA status every 100ms
#define RX_DRAIN_MS         10     // Drain FPGA RX FIFO every 10ms

// ROI frame reception
#define FRAME_MAGIC_0       'F'
#define FRAME_MAGIC_1       'R'

typedef struct __attribute__((packed)) {
    uint8_t  magic[2];
    uint16_t width;
    uint16_t height;
    uint16_t reserved;
} frame_header_t;

// ============================================================================
// State
// ============================================================================

// Frame reception
static uint8_t frame_buffer[BRIDGE_FPGA_FRAME_BUF_SIZE];
static volatile bool frame_ready = false;
static uint16_t current_roi_w = BRIDGE_FPGA_ROI_DEFAULT;
static uint16_t current_roi_h = BRIDGE_FPGA_ROI_DEFAULT;

// CDC receive state machine
typedef enum {
    RX_STATE_IDLE,
    RX_STATE_HEADER,
    RX_STATE_PIXELS
} rx_state_t;

static rx_state_t rx_state = RX_STATE_IDLE;
static uint32_t rx_bytes_expected = 0;
static uint32_t rx_bytes_received = 0;
static frame_header_t pending_header;
static uint8_t header_bytes_received = 0;

// FPGA bridge status (cached)
static fpga_bridge_status_t fpga_status = {0};

// Tracking stats
static uint32_t frames_processed = 0;
static uint32_t commands_sent = 0;
static uint32_t boot_time_ms = 0;

// ============================================================================
// FPGA Initialization
// ============================================================================

static bool init_fpga(void) {
    printf("[FPGA] Initializing iCE40 UP5K...\n");

    // Initialize FPGA clock and reset pins
    ice_fpga_init(FPGA_DATA, 48);  // 48 MHz clock
    ice_fpga_start(FPGA_DATA);

    // Load bitstream into CRAM (volatile - must reload on every boot)
    printf("[FPGA] Loading bitstream (%u bytes)...\n", (unsigned)sizeof(bitstream));

    if (!ice_cram_open(FPGA_DATA)) {
        printf("[FPGA] ERROR: Failed to open CRAM\n");
        return false;
    }

    int ret = ice_cram_write(bitstream, sizeof(bitstream));
    if (ret < 0) {
        printf("[FPGA] ERROR: CRAM write failed (%d)\n", ret);
        return false;
    }

    if (!ice_cram_close()) {
        printf("[FPGA] ERROR: CRAM close failed (CDONE not asserted)\n");
        return false;
    }

    printf("[FPGA] Bitstream loaded successfully, CDONE asserted\n");

    // Small delay for FPGA to initialize internal logic
    sleep_ms(10);

    // Initialize SPI for register access
    if (!fpga_spi_init()) {
        printf("[FPGA] ERROR: SPI register init failed\n");
        return false;
    }

    printf("[FPGA] Bridge engine ready (version 0x%02X)\n", 
           fpga_reg_read(FPGA_REG_VERSION));

    return true;
}

// ============================================================================
// CDC Frame Reception
// ============================================================================

static void cdc_rx_task(void) {
    if (!tud_cdc_available()) return;

    uint8_t buf[64];
    uint32_t count = tud_cdc_read(buf, sizeof(buf));

    for (uint32_t i = 0; i < count; i++) {
        uint8_t c = buf[i];

        switch (rx_state) {
            case RX_STATE_IDLE:
                if (c == FRAME_MAGIC_0) {
                    header_bytes_received = 0;
                    ((uint8_t*)&pending_header)[header_bytes_received++] = c;
                    rx_state = RX_STATE_HEADER;
                }
                break;

            case RX_STATE_HEADER:
                ((uint8_t*)&pending_header)[header_bytes_received++] = c;
                if (header_bytes_received >= sizeof(frame_header_t)) {
                    if (pending_header.magic[1] == FRAME_MAGIC_1 &&
                        pending_header.width <= BRIDGE_FPGA_ROI_MAX &&
                        pending_header.height <= BRIDGE_FPGA_ROI_MAX) {
                        current_roi_w = pending_header.width;
                        current_roi_h = pending_header.height;
                        rx_bytes_expected = current_roi_w * current_roi_h * 3;
                        rx_bytes_received = 0;

                        if (rx_bytes_expected <= sizeof(frame_buffer)) {
                            rx_state = RX_STATE_PIXELS;
                        } else {
                            rx_state = RX_STATE_IDLE;
                        }
                    } else {
                        rx_state = RX_STATE_IDLE;
                    }
                }
                break;

            case RX_STATE_PIXELS:
                frame_buffer[rx_bytes_received++] = c;
                if (rx_bytes_received >= rx_bytes_expected) {
                    frame_ready = true;
                    rx_state = RX_STATE_IDLE;
                }
                break;
        }
    }
}

// ============================================================================
// Tracking & Command Submission
// ============================================================================

static void tracking_task(void) {
    if (!frame_ready) return;
    frame_ready = false;

    if (!tracker_is_enabled()) return;

    tracker_result_t result;
    tracker_process_frame(frame_buffer, current_roi_w, current_roi_h, &result);
    frames_processed++;

    if (result.valid && (result.dx != 0 || result.dy != 0)) {
        // Submit mouse move to FPGA → UART → KMBox
        if (fpga_send_mouse_move(result.dx, result.dy)) {
            commands_sent++;
        }
    }
}

// ============================================================================
// FPGA RX Processing
// ============================================================================

static void fpga_rx_task(void) {
    uint8_t rx_buf[64];
    size_t n = fpga_drain_rx_fifo(rx_buf, sizeof(rx_buf));

    if (n == 0) return;

    // Forward raw KMBox responses to PC via CDC
    if (tud_cdc_connected()) {
        // Parse for known binary packets (info, status)
        // and forward everything to CDC for the PC client to handle
        tud_cdc_write(rx_buf, n);
        tud_cdc_write_flush();
    }
}

// ============================================================================
// Status & Display
// ============================================================================

static void status_task(void) {
    static uint32_t last_poll_ms = 0;
    uint32_t now = to_ms_since_boot(get_absolute_time());

    if (now - last_poll_ms < STATUS_POLL_MS) return;
    last_poll_ms = now;

    // Poll FPGA status registers
    fpga_poll_status(&fpga_status);

    // Update LEDs based on pico-ice SDK LED functions
    // (LEDs are shared between RP2350 and FPGA; FPGA handles its own)
}

// ============================================================================
// Temperature Sensor
// ============================================================================

static float read_temperature_c(void) {
    adc_select_input(4);
    uint16_t raw = adc_read();
    float voltage = (float)raw * (3.3f / 4096.0f);
    return 27.0f - (voltage - 0.706f) * (1.0f / 0.001721f);
}

// ============================================================================
// Main
// ============================================================================

int main(void) {
    // Initialize ADC for temperature sensor
    adc_init();
    adc_set_temp_sensor_enabled(true);

    // Initialize USB CDC + DFU via pico-ice-sdk
    // (blocks until USB host enumerates - handles tud_task internally)
    ice_usb_init();

    printf("\n=== KMBox FPGA Bridge ===\n");
    printf("Board: pico2-ice (RP2350 + iCE40 UP5K)\n");
    printf("CPU: %lu MHz\n", clock_get_hz(clk_sys) / 1000000);

    // Initialize color tracker
    tracker_init();

    // Initialize and load FPGA bitstream
    if (!init_fpga()) {
        printf("FATAL: FPGA initialization failed!\n");
        // Blink red LED to indicate error
        ice_led_init();
        while (1) {
            ice_led_red(true);
            sleep_ms(200);
            ice_led_red(false);
            sleep_ms(200);
        }
    }

    boot_time_ms = to_ms_since_boot(get_absolute_time());
    printf("[Main] FPGA bridge operational. Boot time: %lu ms\n", boot_time_ms);

    // ========================================================================
    // Main loop - all processing on Core 0
    // Core 1 is free for future TFT display offloading
    // ========================================================================
    while (1) {
        // USB housekeeping (TinyUSB)
        tud_task();

        // Receive frames from PC via USB CDC
        cdc_rx_task();

        // Process frames through color tracker
        tracking_task();

        // Read responses from FPGA RX FIFO
        fpga_rx_task();

        // Poll FPGA status (throttled)
        status_task();
    }

    return 0;
}
