/**
 * KMBox FPGA Bridge - Main Firmware
 *
 * Runs on the RP2350 side of the pico2-ice board.
 * The iCE40 FPGA handles all KMBox SPI communication as a smart
 * SPI→SPI relay with auto-ping keepalive and connection tracking.
 *
 * The RP2350 handles:
 *   - USB CDC interface for receiving commands/frames from PC
 *   - Color tracking (when frames are received)
 *   - KMBox fast binary packet construction (sent to FPGA via PIO SPI)
 *   - Side channel UART to KMBox (status/control, bypasses FPGA)
 *
 * Architecture:
 *   PC ←(USB CDC)→ RP2350 ←(SPI 12M)→ iCE40 FPGA ←(SPI 12M)→ KMBox
 *                     |
 *                  UART0: Side channel to KMBox (GPIO 20 TX, 25 RX)
 *                  Pico RGB LED: GPIO 0(G), 1(R), 9(B)
 *
 * LED Architecture (two separate physical RGB LEDs + DONE LED):
 *   Pico RGB LED (RP2350): GPIO 0=Green, 1=Red, 9=Blue
 *     Green = KMBox connected (solid)
 *     Red   = KMBox disconnected (blinks 4 Hz)
 *     Blue  = USB CDC connected (PC link active)
 *
 *   FPGA RGB LED (iCE40):  ICE pins 39=Green, 41=Red, 40=Blue
 *     Green = KMBox SPI connected
 *     Red   = KMBox SPI disconnected (blinks 1 Hz)
 *     Blue  = SPI activity (brief flash per transaction)
 *
 *   FPGA DONE LED: GPIO 40 (CDONE) — hardware, lights when bitstream loaded
 *
 * Boot sequence:
 *   1. Init ADC
 *   2. Load FPGA bitstream via CRAM (uses PIO SPI on GPIO 4/6, verify CDONE)
 *   3. Switch GPIO 4-7 to PIO2 SPI master (FPGA communication)
 *   4. Init USB CDC (blocks until enumerated)
 *   5. Init side channel UART (GPIO 20 TX, GPIO 25 RX)
 *   6. Init RGB status LEDs (GPIO 0=green, 1=red, 9=blue)
 *   7. Init color tracker
 *   8. Main loop
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pico/stdlib.h"
#include "pico/binary_info.h"
#include "hardware/spi.h"
#include "hardware/clocks.h"
#include "hardware/adc.h"

// pico-ice-sdk
#include "boards.h"
#include "ice_usb.h"
#include "ice_fpga.h"
#include "ice_cram.h"
#include "ice_led.h"

// Local modules
#include "fpga_spi.h"
#include "side_channel.h"
#ifndef DISABLE_TFT
#include "tft_display.h"
#endif
#include "config.h"
#include "tracker.h"

// FPGA bitstream (generated by synthesis toolchain -> bin2header.py)
#include "bitstream.h"

// ============================================================================
// Configuration
// ============================================================================

#define CDC_RX_BUFFER_SIZE  4096

// ROI frame reception
#define FRAME_MAGIC_0       'F'
#define FRAME_MAGIC_1       'R'

typedef struct __attribute__((packed)) {
    uint8_t  magic[2];
    uint16_t width;
    uint16_t height;
    uint16_t reserved;
} frame_header_t;

// ============================================================================
// State
// ============================================================================

// Frame reception
static uint8_t frame_buffer[BRIDGE_FPGA_FRAME_BUF_SIZE];
static volatile bool frame_ready = false;
static uint16_t current_roi_w = BRIDGE_FPGA_ROI_DEFAULT;
static uint16_t current_roi_h = BRIDGE_FPGA_ROI_DEFAULT;

// CDC receive state machine
typedef enum {
    RX_STATE_IDLE,
    RX_STATE_HEADER,
    RX_STATE_PIXELS
} rx_state_t;

static rx_state_t rx_state = RX_STATE_IDLE;
static uint32_t rx_bytes_expected = 0;
static uint32_t rx_bytes_received = 0;
static frame_header_t pending_header;
static uint8_t header_bytes_received = 0;

// Stats
static uint32_t frames_processed = 0;
static uint32_t commands_sent = 0;
static uint32_t commands_this_sec = 0;
static uint32_t commands_per_sec = 0;
static uint32_t last_rate_ms = 0;
static uint32_t boot_time_ms = 0;

// Last tracking result (for display)
static int16_t last_dx = 0, last_dy = 0;
static uint16_t last_blob_size = 0;

// ============================================================================
// FPGA Initialization
// ============================================================================

static bool init_fpga(void) {
    printf("[FPGA] Initializing iCE40 UP5K...\n");

    // Initialize FPGA clock (48 MHz on GPIO 21) and CRESET pin (GPIO 31)
    ice_fpga_init(FPGA_DATA, 48);
    ice_fpga_start(FPGA_DATA);

    // Load bitstream into CRAM (volatile - must reload on every boot)
    printf("[FPGA] Loading bitstream (%u bytes)...\n", (unsigned)sizeof(bitstream));

    if (!ice_cram_open(FPGA_DATA)) {
        printf("[FPGA] ERROR: Failed to open CRAM\n");
        return false;
    }

    int ret = ice_cram_write(bitstream, sizeof(bitstream));
    if (ret < 0) {
        printf("[FPGA] ERROR: CRAM write failed (%d)\n", ret);
        return false;
    }

    if (!ice_cram_close()) {
        printf("[FPGA] ERROR: CRAM close failed\n");
        return false;
    }

    // Verify CDONE actually asserted (ice_cram_close only checks CRESET)
    sleep_ms(1);
    gpio_init(FPGA_DATA.pin_cdone);
    if (!gpio_get(FPGA_DATA.pin_cdone)) {
        printf("[FPGA] ERROR: CDONE not asserted — bitstream rejected\n");
        return false;
    }

    printf("[FPGA] Bitstream loaded, CDONE asserted\n");

    // Small delay for FPGA to initialize internal logic
    sleep_ms(10);

    // Switch GPIO 4-7 from SPI0 to PIO2 SPI master for FPGA communication
    if (!fpga_spi_init()) {
        printf("[FPGA] ERROR: SPI init failed\n");
        return false;
    }

    printf("[FPGA] Bridge engine ready via PIO2 SPI\n");
    return true;
}

// ============================================================================
// CDC Frame Reception
// ============================================================================

static void cdc_rx_task(void) {
    if (!tud_cdc_available()) return;

    uint8_t buf[64];
    uint32_t count = tud_cdc_read(buf, sizeof(buf));

    for (uint32_t i = 0; i < count; i++) {
        uint8_t c = buf[i];

        switch (rx_state) {
            case RX_STATE_IDLE:
                if (c == FRAME_MAGIC_0) {
                    header_bytes_received = 0;
                    ((uint8_t*)&pending_header)[header_bytes_received++] = c;
                    rx_state = RX_STATE_HEADER;
                }
                break;

            case RX_STATE_HEADER:
                ((uint8_t*)&pending_header)[header_bytes_received++] = c;
                if (header_bytes_received >= sizeof(frame_header_t)) {
                    if (pending_header.magic[1] == FRAME_MAGIC_1 &&
                        pending_header.width <= BRIDGE_FPGA_ROI_MAX &&
                        pending_header.height <= BRIDGE_FPGA_ROI_MAX) {
                        current_roi_w = pending_header.width;
                        current_roi_h = pending_header.height;
                        rx_bytes_expected = current_roi_w * current_roi_h * 3;
                        rx_bytes_received = 0;

                        if (rx_bytes_expected <= sizeof(frame_buffer)) {
                            rx_state = RX_STATE_PIXELS;
                        } else {
                            rx_state = RX_STATE_IDLE;
                        }
                    } else {
                        rx_state = RX_STATE_IDLE;
                    }
                }
                break;

            case RX_STATE_PIXELS:
                frame_buffer[rx_bytes_received++] = c;
                if (rx_bytes_received >= rx_bytes_expected) {
                    frame_ready = true;
                    rx_state = RX_STATE_IDLE;
                }
                break;
        }
    }
}

// ============================================================================
// Tracking & Command Submission
// ============================================================================

static void tracking_task(void) {
    if (!frame_ready) return;
    frame_ready = false;

    if (!tracker_is_enabled()) return;

    tracker_result_t result;
    tracker_process_frame(frame_buffer, current_roi_w, current_roi_h, &result);
    frames_processed++;

    last_dx = result.dx;
    last_dy = result.dy;
    last_blob_size = result.blob_size;

    if (result.valid && (result.dx != 0 || result.dy != 0)) {
        fpga_response_t resp = fpga_send_mouse_move(result.dx, result.dy);
        if (resp.status & FPGA_STATUS_CMD_OK) {
            commands_sent++;
            commands_this_sec++;
        }
    }
}

// ============================================================================
// FPGA RX Processing
// ============================================================================

static void fpga_rx_task(void) {
    uint8_t rx_buf[64];
    size_t n = fpga_drain_rx(rx_buf, sizeof(rx_buf));

    if (n == 0) return;

    // Forward raw KMBox responses to PC via CDC
    if (tud_cdc_connected()) {
        tud_cdc_write(rx_buf, n);
        tud_cdc_write_flush();
    }
}

// ============================================================================
// Status & Stats
// ============================================================================

static float read_temperature_c(void) {
    adc_select_input(4);
    uint16_t raw = adc_read();
    float voltage = (float)raw * (3.3f / 4096.0f);
    return 27.0f - (voltage - 0.706f) * (1.0f / 0.001721f);
}

static void stats_task(void) {
    uint32_t now = to_ms_since_boot(get_absolute_time());

    // Update commands/sec rate every second
    if (now - last_rate_ms >= 1000) {
        commands_per_sec = commands_this_sec;
        commands_this_sec = 0;
        last_rate_ms = now;
    }

#ifndef DISABLE_TFT
    // Pull KMBox status from side channel and submit to TFT
    const side_channel_status_t *km = side_channel_get_status();
    // Submit stats to TFT display
    tft_stats_t stats = {
        .cdc_connected = tud_cdc_connected(),
        .kmbox_connected = fpga_is_connected(),
        .tracker_enabled = tracker_is_enabled(),
        .frames_processed = frames_processed,
        .last_dx = last_dx,
        .last_dy = last_dy,
        .blob_size = last_blob_size,
        .commands_sent = commands_sent,
        .commands_per_sec = commands_per_sec,
        .uptime_sec = (now - boot_time_ms) / 1000,
        .cpu_freq_mhz = clock_get_hz(clk_sys) / 1000000,
        .temperature_c = read_temperature_c(),
        // KMBox status from side channel
        .km_humanization_mode = km->humanization_mode,
        .km_inject_mode = km->inject_mode,
        .km_temperature_c = km->info_valid ? (float)km->temperature_decideg / 10.0f : 0.0f,
        .km_queue_count = km->queue_count,
        .km_mouse_connected = km->mouse_connected,
        .km_vid = km->vid,
        .km_pid = km->pid,
    };
    if (km->strings_valid) {
        strncpy(stats.km_manufacturer, km->manufacturer, sizeof(stats.km_manufacturer) - 1);
        strncpy(stats.km_product, km->product, sizeof(stats.km_product) - 1);
    }
    tft_display_submit_stats(&stats);
#endif
}

// ============================================================================
// Touch handling
// ============================================================================

#ifndef DISABLE_TFT
static void process_touch(void) {
    tft_display_handle_touch();

    if (touch_tracker_toggle_requested) {
        touch_tracker_toggle_requested = false;
        if (tracker_is_enabled())
            tracker_set_enabled(false);
        else
            tracker_set_enabled(true);
        printf("[Touch] Tracker %s\n", tracker_is_enabled() ? "enabled" : "disabled");
    }
}
#endif

// ============================================================================
// Main
// ============================================================================

int main(void) {
    // Initialize ADC for temperature sensor
    adc_init();
    adc_set_temp_sensor_enabled(true);

    // Program the FPGA FIRST — before USB, which blocks until enumeration.
    // The iCE40 bitstream must be loaded via CRAM on every boot.
    if (!init_fpga()) {
        // No printf yet (USB not up), so just blink red
        ice_led_init();
        while (1) {
            ice_led_red(true);
            sleep_ms(200);
            ice_led_red(false);
            sleep_ms(200);
        }
    }

    // Initialize USB CDC + DFU via pico-ice-sdk
    // (blocks until USB host enumerates)
    ice_usb_init();

    printf("\n=== KMBox FPGA Bridge ===\n");
    printf("Board: pico2-ice (RP2350B + iCE40 UP5K)\n");
    printf("CPU: %lu MHz\n", clock_get_hz(clk_sys) / 1000000);
    printf("[FPGA] Bitstream loaded, bridge engine running\n");

    // Initialize side channel UART to KMBox (GPIO 20/21, bypasses FPGA)
    side_channel_init();

    // Initialize RGB status LEDs (GPIO 0=green, 1=red, 9=blue)
    // These pins are now free since UART moved to GPIO 20/21
    ice_led_init();
    ice_led_red(false);
    ice_led_green(false);
    ice_led_blue(true);   // Blue = initializing
    printf("[LED] RGB status LEDs initialized (R=GPIO1, G=GPIO0, B=GPIO9)\n");

#ifndef DISABLE_TFT
    // Initialize TFT display + touch (uses SPI0 on GPIO 35-38, I2C1 on GPIO 26/27)
    if (!tft_display_init()) {
        printf("WARNING: TFT display init failed, continuing without display\n");
    } else {
        tft_display_splash();
    }
#else
    printf("[TFT] Display disabled (DISABLE_TFT=1)\n");
#endif

    // Initialize color tracker
    tracker_init();

    boot_time_ms = to_ms_since_boot(get_absolute_time());
    printf("[Main] FPGA bridge operational. Boot time: %lu ms\n", boot_time_ms);

    // LED: all off until status known
    ice_led_blue(false);
    ice_led_green(false);
    ice_led_red(false);

    // ========================================================================
    // Main loop
    // ========================================================================
    absolute_time_t last_led = get_absolute_time();
    bool red_blink = false;

    while (1) {
        // USB housekeeping (TinyUSB)
        tud_task();

        // Receive frames from PC via USB CDC
        cdc_rx_task();

        // Process frames through color tracker → send commands via SPI
        tracking_task();

        // Read KMBox responses from FPGA via SPI → forward to CDC
        fpga_rx_task();

        // Side channel: poll KMBox status via UART0 (bypasses FPGA)
        side_channel_task();

#ifndef DISABLE_TFT
        // Flush rendered TFT frame via SPI DMA
        tft_display_flush();

        // Poll touch and handle events
        process_touch();
#endif

        // Update stats for display
        stats_task();

        // Pico RGB LED: status display at ~4 Hz
        if (absolute_time_diff_us(last_led, get_absolute_time()) > 250000) {
            red_blink = !red_blink;
            last_led = get_absolute_time();

            bool km_conn = fpga_is_connected();
            ice_led_green(km_conn);                          // Green = KMBox connected
            ice_led_red(!km_conn && red_blink);              // Red blink = disconnected
            ice_led_blue(tud_cdc_connected());               // Blue = CDC connected
        }
    }

    return 0;
}
