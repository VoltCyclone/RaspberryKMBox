; Bridge Protocol UART RX
; Standard UART RX at 2 Mbaud
; Sync detection handled in software

.program bridge_uart_rx

; Standard 8N1 UART receiver
.wrap_target
start:
    wait 0 pin 0                    ; Wait for start bit
    set x, 7            [10]        ; 8 bits to receive, delay to center
bitloop:
    in pins, 1                      ; Sample data bit
    jmp x-- bitloop     [6]         ; Loop for all 8 bits
    
    ; Check stop bit (should be high)
    jmp pin good_stop               ; If high, we have valid byte
    jmp start                       ; Bad stop bit, resync
    
good_stop:
    push                            ; Push received byte to FIFO
.wrap

% c-sdk {
#include "hardware/clocks.h"

static inline void bridge_uart_rx_program_init(PIO pio, uint sm, uint offset, uint pin, uint baud) {
    pio_sm_config c = bridge_uart_rx_program_get_default_config(offset);
    
    sm_config_set_in_pins(&c, pin);
    sm_config_set_jmp_pin(&c, pin);
    
    pio_gpio_init(pio, pin);
    gpio_pull_up(pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
    
    // 16 cycles per bit for oversampling
    float div = (float)clock_get_hz(clk_sys) / (16 * baud);
    sm_config_set_clkdiv(&c, div);
    
    sm_config_set_in_shift(&c, true, true, 8);  // Shift right, autopush at 8
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

static inline uint8_t bridge_uart_rx_getc(PIO pio, uint sm) {
    return (uint8_t)pio_sm_get_blocking(pio, sm);
}

static inline bool bridge_uart_rx_available(PIO pio, uint sm) {
    return !pio_sm_is_rx_fifo_empty(pio, sm);
}
%}
