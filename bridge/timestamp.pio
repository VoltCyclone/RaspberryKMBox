; High-Precision Timestamp Counter PIO Program
; 
; Uses PIO to provide sub-microsecond timing capabilities
; for precise command latency measurement and synchronization.
;
; Features:
; - Free-running counter at configurable resolution
; - Capture timestamps on GPIO edge events
; - Provides timing independent of CPU load
;
; Usage:
; - Initialize with desired clock divider for resolution
; - Read counter via FIFO or direct register access
; - Use autopush to stream timestamps

.program timestamp_counter
; Simply counts at PIO clock rate
; Counter value available in X register and pushed to FIFO

.wrap_target
    mov x, !null       ; Reset to 0xFFFFFFFF
count_loop:
    jmp x-- count_loop ; Decrement until 0 (free-running)
    push noblock       ; Push overflow marker (non-blocking)
.wrap

% c-sdk {
#include "hardware/clocks.h"

static inline void timestamp_counter_program_init(PIO pio, uint sm, uint offset, float freq_hz) {
    pio_sm_config c = timestamp_counter_program_get_default_config(offset);
    
    // No pins needed for basic counter
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    
    // Calculate clock divider for desired frequency
    float div = (float)clock_get_hz(clk_sys) / freq_hz;
    sm_config_set_clkdiv(&c, div);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// Read current counter value (fast, direct register access)
static inline uint32_t timestamp_get_count(PIO pio, uint sm) {
    // Force exec to push current X to FIFO
    pio_sm_exec(pio, sm, pio_encode_push(false, false));
    return pio_sm_get_blocking(pio, sm);
}

%}

.program edge_timestamp
; Captures timestamp on GPIO rising edge
; Reports elapsed cycles since start

    set x, 0           ; Initialize counter
wait_edge:
    jmp pin edge_found ; Check input pin
    jmp x-- wait_edge  ; Count while waiting
    jmp wait_edge      ; Handle overflow (wrap)
edge_found:
    mov isr, x         ; Copy counter to ISR
    push               ; Send timestamp
    set x, 0           ; Reset counter
    wait 0 pin 0       ; Wait for pin to go low
    jmp wait_edge      ; Go back to waiting

% c-sdk {
#include "hardware/clocks.h"

static inline void edge_timestamp_program_init(PIO pio, uint sm, uint offset, uint pin, float freq_hz) {
    pio_sm_config c = edge_timestamp_program_get_default_config(offset);
    
    // Configure input pin
    sm_config_set_jmp_pin(&c, pin);
    sm_config_set_in_pins(&c, pin);
    pio_gpio_init(pio, pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
    
    // Pull-up on input
    gpio_pull_up(pin);
    
    // Clock divider for desired resolution
    float div = (float)clock_get_hz(clk_sys) / freq_hz;
    sm_config_set_clkdiv(&c, div);
    
    // RX FIFO for timestamps
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    sm_config_set_in_shift(&c, false, true, 32);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// Check if timestamp is available
static inline bool edge_timestamp_available(PIO pio, uint sm) {
    return !pio_sm_is_rx_fifo_empty(pio, sm);
}

// Get timestamp (blocking)
static inline uint32_t edge_timestamp_get(PIO pio, uint sm) {
    return pio_sm_get_blocking(pio, sm);
}

%}
